인스턴스 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하며 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부름 

인스턴스 필드/메소드는 객체에 소속된 멤버이기 때문에 객체없이 사용 불가 

this>
객체 외부에서 인스턴스 멤버에 접근하기 위해 참조변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용 
this는 주로 생성자와 메소드의 매개 변수 이름이 동일한 경우 , 인스턴스 멤버인 필드임을 명시하고자 할 때 사용 

정적멤버 : 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드로 이들을 각각 정적 필드, 정적 메소드라고 부름 

선언  
public class 클래스 {
    // 정적필드
    static 타입 필드 [=초기값];

    // 정적메소드
    static 리턴 타입 메소드(매개변수선언, ,,) { }
}

정적필드와 정적메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됨 따라서 클래스로딩이 끝나면 바로 사용 가능 

인스턴스 필드를 포함하고 있다면 -> 인스턴스 메소드로 선언
인스턴스 필드르 포함하고 있지 않다면 -> 정적메소드로 선언 

클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데 클래스 이름과 함께 도트연산자로 접근함 
선언 : 클래스.필드;
       클래스.메소드( 매개값, ,,);

정적필드와 정적메소드는 원칙적으로는 클래스 이름으로 접근해야 하지만 객체참조변수로도 접근 가능 

정적메소드 선언시 주의할 점 
-> 객체가 없어도 실행된다는 특징 떄문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없음 또한 객체 자신의 참조인 this 키워드도 사용이 불가 
정적메소드에서 인스턴스 멤버를 사용하고 싶다면 => 객체를 먼저 생성하고 참조변수로 접근해야 함 

main()메소드도 마찬가지로 정적메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main()메소드에서 바로 사용할 수 없음 

싱글톤 : 전체 프로그램에서 하나의 개체만 만들도록 보장하는 것 
싱글톤을 만들려면 클래스 외부에서 new연산자로 생성자를 호출할 수 없도록 막아야 함 - 생성자를 호출한 만큼 객체가 생성되기 때문
=> 생성자 앞에 private 접근 제한자를 붙여주면 됨 

자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화함 
cf 클래스 내부에서는 new 연산자로 생성자 호출이 간으 
정적필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하게 막음 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해줌 

외부에서 객체를 얻는 유일한 방법 : getInstance() 메소드 호출 

final필드 : 초기값이 저정되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것 
선언 : final 타입 필드 [=초기값];

final 필드의 초기값을 줄 수 있는 방법 
1. 필드 선언 시에 주는 방법
2. 생성자에서 주는 방법 
-> 단순 값이라면 필드 선언 시에 주는 것이 제일 간단하지만 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정 
생성자는 final 필드의 최종 초기화를 마쳐야 하는데 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생 

상수 : 불변의 값을 저장하는 필드 
final필드를 상수라고 부르지 않음 왜냐하면 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며 여러가지 값으로 초기화될 수 없기 때문 
final필드는 객체마다 저장되고 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없음 
=> 따라서 상수는 static이면서 final이여야 함 
선언 : static final 타입 상수 = 초기값;

