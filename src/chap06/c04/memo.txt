메소드 선언은 선언부와 실행 블록으로 구성 

선언부와 실행 블록의 요소 
1. 리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시 
2. 메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어줌  
3. 매개 변순 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수 선언 
4. 메소드 실행 블록 : 실행할 코드를 작성 

리턴타입 메소드이름 ( [매개변수 선언, ,,] ) {
    실행 코드;
}

리턴 타입>
리턴값 : 메소드를 실행한 후의 결과값 
리턴값은 있을수도 없을수도 있으며 있을 경우 리턴 타입이 선언부에 명시되어야 함 
리턴타입이 있다고 해서 반드시 리턴값을 변수에 저장할 필요는 없음, 리턴값이 중요하지 않고 메소드 실행이 중요할 경우 변수 선언하지 않고 메소드 호출 가능 

메소드 이름>
숫자로 시작x, 특수문자 사용x, 소문자로, 두단어 혼합시 뒷단어 대문자로 시작 

매개 변수 선언>
매개변수 -> 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용 
매개값은 반드시 매게 변수의 타입에 부합되는 값이어야 함 
예를들어 메소드가 int 타입 매개변수를 가지고 있다면 호출 시 매개값으로 int값이냐 int로 변환될 수 있는 값을 넘겨주어야 함 

메소드를 선언할 때 매개 변수의 개수를 모를 경우 => 매개변수를 배열 타입으로 선언
    ex. int sum1(int[] values) { }
배열의 항목수는 호출할 때 결정됨 

                                            => 또는 배열 생성하지 않고 값의 목록만 넘겨줌 왜냐면 메소드 호출하기 전에 배열을 선언해야하는 불편함이 있으니까 -- 매개변수를 ...을 사용해서 선언하면 
                                                                                                                                                    메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열 생성되고 매개값으로 사용 
    ex. int sum2(int ... values)

    ...으로 선언된 매개변수의 값은 메소드 호출 시 쉼표로 나열해줌 
        ex. int result = sum2(1, 2, 3)

리턴값이 있는 메소드>
메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 함 
만약 리턴문이 없다면 컴파일에러가 발생하고 리턴문이 실행되면 메소드는 즉시 종료됨 
리턴문의 리턴값 : 리턴타입이거나 리턴타입으로 변환 가능해야 함 

리턴값이 없느 메소드>
리턴값이 없을 경우 리턴타입으로 void를 사용 
void로 선언된 메소드에서도 리턴문을 사용할 수 있음, 이것은 리턴값을 지정하는것이 아니라 메소드 실행을 강제로 종료시키는 역할을 함 

메소드 호출>
클래스 내부의 다른 메소드에서 호출할 경우 -> 단순한 메소드 이름으로 호출
    호출 형태 : 메소드( 매개값, ,,)
    메소드가 매개변수를 가지고 있을 때에는 매개변수의 타입과 수에 맞게 매개값을 제공

클래스 외부에서 호출할 경우 -> 클래스로부터 객체를 생성한 뒤 참조변수를 이용해서 메소드를 호출해야 함 왜냐하면 객체가 존재해야 메소드도 존재하니까 
    호출 형태 : 클래스 참조변수 = new 클래스( 매개값, ,,)
    객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출 
    도트 연산자 = 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근할 때 사용됨 
    형태 : 참조변서.메소드( 매개값, ,,) // 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
           타입 변수 = 참조변수.메소드( 매개값, ,,) // 리턴값이 있고, 리턴값을 받고 싶은 경우 

메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것 -> 매개값을 다양하게 받아 처리할 수 있도록 하기 위해 사용 
    조건 = 매개변수의 타입, 개수, 순서 중 하나가 달라야 함 

    class 클래스 {
        리턴타입1 메소드이름1 ( 타입 변수1, ,,,) { }
        리턴타입2 메소드이름2 ( 타입 변수2, ,,,) { }
    } 
    // 리턴타입1 = 리터타입2 (상관없음)
    // 메소드이름1 = 메소드이름2 (동일)
    // 타입변수1 != 타입변수2 (달라야함)

    주의점 : 매개변수의 타입과 개수, 순서가 똑같을 경우 매개변수 이름이 다르다고 해서 메소드 오버로딩이라고 하지않음 
            또한 리턴타입만 다르고 매개변수가 동일하다면 이것도 오버로딩이 아님 

